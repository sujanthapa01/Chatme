import {
  require_fs,
  require_path
} from "./chunk-AZNXDYHA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LQ2VYIYD.js";

// node_modules/vite-plugin-env-compatible/node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/vite-plugin-env-compatible/node_modules/dotenv/lib/main.js"(exports, module) {
    var fs = require_fs();
    var path = require_path();
    function log(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\n|\r|\r\n/;
    function parse(src, options) {
      const debug = Boolean(options && options.debug);
      const obj = {};
      src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
        const keyValueArr = line.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key = keyValueArr[1];
          let val = keyValueArr[2] || "";
          const end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key] = val;
        } else if (debug) {
          log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
        }
      });
      return obj;
    }
    function config(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let debug = false;
      if (options) {
        if (options.path != null) {
          dotenvPath = options.path;
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
        if (options.debug != null) {
          debug = true;
        }
      }
      try {
        const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug });
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else if (debug) {
            log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
          }
        });
        return { parsed };
      } catch (e) {
        return { error: e };
      }
    }
    module.exports.config = config;
    module.exports.parse = parse;
  }
});

// node_modules/dotenv-expand/lib/main.js
var require_main2 = __commonJS({
  "node_modules/dotenv-expand/lib/main.js"(exports, module) {
    "use strict";
    var dotenvExpand = function(config) {
      var environment = config.ignoreProcessEnv ? {} : process.env;
      var interpolate = function(envValue) {
        var matches = envValue.match(/(.?\${?(?:[a-zA-Z0-9_]+)?}?)/g) || [];
        return matches.reduce(function(newEnv, match) {
          var parts = /(.?)\${?([a-zA-Z0-9_]+)?}?/g.exec(match);
          var prefix = parts[1];
          var value2, replacePart;
          if (prefix === "\\") {
            replacePart = parts[0];
            value2 = replacePart.replace("\\$", "$");
          } else {
            var key = parts[2];
            replacePart = parts[0].substring(prefix.length);
            value2 = environment.hasOwnProperty(key) ? environment[key] : config.parsed[key] || "";
            value2 = interpolate(value2);
          }
          return newEnv.replace(replacePart, value2);
        }, envValue);
      };
      for (var configKey in config.parsed) {
        var value = environment.hasOwnProperty(configKey) ? environment[configKey] : config.parsed[configKey];
        config.parsed[configKey] = interpolate(value);
      }
      for (var processKey in config.parsed) {
        environment[processKey] = config.parsed[processKey];
      }
      return config;
    };
    module.exports = dotenvExpand;
  }
});

// node_modules/vite-plugin-env-compatible/dist/index.mjs
var import_path = __toESM(require_path(), 1);
var import_fs = __toESM(require_fs(), 1);
var import_dotenv = __toESM(require_main(), 1);
var import_dotenv_expand = __toESM(require_main2(), 1);
var import_path2 = __toESM(require_path(), 1);
function u(i, e, n = false) {
  for (let p of e) {
    let t = import_path.default.join(i, p);
    if (import_fs.default.existsSync(t) && import_fs.default.statSync(t).isFile())
      return n ? t : import_fs.default.readFileSync(t, "utf-8");
  }
  let s = import_path.default.dirname(i);
  if (s !== i)
    return u(s, e, n);
}
function v(i) {
  let { mode: e, envDir: n, prefix: s, ignoreProcessEnv: p } = i;
  if (e === "local")
    throw new Error('"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.');
  let t = {}, a = [`.env.${e}.local`, `.env.${e}`, ".env.local", ".env"];
  for (let o in process.env)
    o.startsWith(s) && t[o] === void 0 && (t[o] = process.env[o]);
  for (let o of a) {
    let l = u(n, [o], true);
    if (l) {
      let c = import_dotenv.default.parse(import_fs.default.readFileSync(l), { debug: !!process.env.DEBUG || void 0 });
      (0, import_dotenv_expand.default)({ parsed: c, ignoreProcessEnv: p });
      for (let [r, d] of Object.entries(c))
        r.startsWith(s) && t[r] === void 0 ? t[r] = d : r === "NODE_ENV" && (process.env.VITE_USER_NODE_ENV = d);
    }
  }
  return t;
}
function g(i) {
  let e = {};
  return Object.keys(process.env).map((n) => {
    String(n).includes(i) && (e[n] = process.env[n] || "");
  }), e;
}
var b = "vite-plugin-env-compatible";
function j(i = {}) {
  let e = { mountedPath: "process.env", ...i };
  return { name: b, enforce: "pre", config(n, { mode: s }) {
    var _a;
    let p = n.root || process.cwd(), t = n.envDir || "./";
    import_path2.default.isAbsolute(t || "") || (t = import_path2.default.join(p, t));
    let a = typeof e.prefix > "u" ? "VUE_APP_" : e.prefix, o = v({ mode: s, envDir: t, prefix: a, ignoreProcessEnv: e.ignoreProcessEnv ?? false }), l = g(a), c = {};
    ((_a = e.mountedPath) == null ? void 0 : _a.startsWith("process.env")) && (c["process.env.VITE"] = JSON.stringify(true)), Object.keys({ ...o, ...l }).map((r) => {
      let d = o[r];
      c[`${e.mountedPath}.${r}`] = JSON.stringify(d);
    }), n.define = { ...n.define || {}, ...c };
  } };
}
export {
  j as default
};
//# sourceMappingURL=vite-plugin-env-compatible.js.map
